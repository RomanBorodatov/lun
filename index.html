<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lun NY Truck</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v1.6.1/mapbox-gl.js"></script>
    <script
      src="https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v2.0.0/turf.min.js"
      charset="utf-8"
    ></script>
    <link
      href="https://api.tiles.mapbox.com/mapbox-gl-js/v1.6.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      #carImage {
        width: 50px;
      }

      .controls-container {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        align-items: center;
      }

      #run-button {
        height: 50px;
        width: 100px;
        background-color: #ff9800;
        border: none;
        border-radius: 25px;
        margin-left: 15px;

        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <img src="./car2.svg" alt="car" id="carImage" />
    <div class="controls-container">
      <audio controls loop src="./music2.mp3" id="audio">
        Your browser does not support the
        <code>audio</code> element.
      </audio>
      <button disabled id="run-button">Run Animation</button>
    </div>
    <script>
      mapboxgl.accessToken =
        "pk.eyJ1Ijoicm9tYW5ib3JvZGF0b3YiLCJhIjoiY2sxa2w3N3Y1MDdvZjNibzNveXFidWpuaSJ9.h9858JVC3HbU02hxED68eg";
      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/navigation-guidance-night-v4",
        center: [30.4711555, 50.386974],
        zoom: 14
      });

      const origin = [30.4711555, 50.386974];
      const destination = [30.480598, 50.37886];
      const carImage = document.getElementById("carImage");
      let marker;
      let route;
      let smoothRoute;
      const runButton = document.getElementById("run-button");
      const audioTrack = document.getElementById("audio");

      const animateRouteChunk = index => {
        return new Promise(resolve => {
          let routeChunk = {
            type: "FeatureCollection",
            features: [
              {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: [smoothRoute[index], smoothRoute[index + 1]]
                }
              }
            ]
          };
          const distance = turf.lineDistance(
            routeChunk.features[0],
            "kilometers"
          );

          const duration = Math.round((distance * 1000) / 0.0139 / 10);

          const currentMarkerAngle = marker.getRotation();
          const currentMarkerPosition = marker.getLngLat();

          const ease = ({ distance, durationMs, onStep }) => {
            const raf =
              window.requestAnimationFrame ||
              (func => window.setTimeout(func, 16));

            const stepCount = durationMs / 16 > 120 ? durationMs / 16 : 120;
            const valueIncrement = distance / stepCount;
            const sinValueIncrement = Math.PI / stepCount;

            let currentValue = 0;
            let currentSinValue = 0;

            function step() {
              currentSinValue += sinValueIncrement;
              currentValue +=
                valueIncrement * Math.sin(currentSinValue) ** 2 * 2;

              if (currentSinValue < Math.PI) {
                onStep(currentValue);
                raf(step);
              } else {
                resolve();
              }
            }

            raf(step);
          };

          let rotated = 0;

          const targetAngle = turf.bearing(
            turf.point([currentMarkerPosition.lng, currentMarkerPosition.lat]),
            turf.point(routeChunk.features[0].geometry.coordinates[1])
          );

          const currentAngle = marker.getRotation();

          const delta = ((targetAngle - currentAngle + 540) % 360) - 180;

          const moveMarker = distance => {
            const newPosition = turf.along(
              routeChunk.features[0],
              distance,
              "kilometers"
            ).geometry.coordinates;

            marker.setLngLat(newPosition);

            if (rotated <= 20) {
              marker.setRotation(currentAngle + delta * 0.05 * rotated);
              rotated += 1;
            }
          };

          ease({
            distance: distance,
            durationMs: duration,
            onStep: moveMarker
          });

          // const toRotate = turf.bearing(
          //   turf.point([currentMarkerPosition.lng, currentMarkerPosition.lat]),
          //   turf.point(routeChunk.features[0].geometry.coordinates[1])
          // );

          // const detailedPath = [];

          // const steps = distance / 0.005;

          // for (i = 0; i < distance; i += distance / steps) {
          //   const segment = turf.along(routeChunk.features[0], i, "kilometers");
          //   detailedPath.push(segment.geometry.coordinates);
          // }

          // let counter = 0;
          // let rotated = false;

          // const animate = () => {
          //   if (!rotated) {
          //     marker.setRotation(toRotate);
          //   }
          //   if (detailedPath[counter]) {
          //     marker.setLngLat(detailedPath[counter]);
          //   }

          //   if (counter < steps) {
          //     requestAnimationFrame(animate);
          //   } else {
          //     resolve();
          //   }

          //   counter = counter + 1;
          // };

          // animate();
        });
      };

      const animateWayBack = () => {
        return new Promise(resolve => {
          const roadBack = {
            type: "FeatureCollection",
            features: [
              {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: [destination, origin]
                }
              }
            ]
          };

          const from = turf.point(destination);
          const to = turf.point(origin);

          var distance = turf.lineDistance(roadBack.features[0], "kilometers");

          const steps = 250;

          const arc = [];

          for (let i = 0; i < distance; i += distance / steps) {
            const segment = turf.along(roadBack.features[0], i, "kilometers");
            arc.push(segment.geometry.coordinates);
          }

          roadBack.features[0].geometry.coordinates = arc;

          let counter = 0;

          animate = () => {
            const currentMarkerPosition = marker.getLngLat();

            if (roadBack.features[0].geometry.coordinates[counter]) {
              const targetAngle = turf.bearing(
                turf.point([
                  currentMarkerPosition.lng,
                  currentMarkerPosition.lat
                ]),
                turf.point(roadBack.features[0].geometry.coordinates[counter])
              );
              marker.setLngLat(
                roadBack.features[0].geometry.coordinates[counter]
              );
              marker.setRotation(targetAngle);
            }

            // Request the next frame of animation so long the end has not been reached.
            if (counter < steps) {
              requestAnimationFrame(animate);
            } else {
              resolve();
            }

            counter = counter + 1;
          };
          animate();
        });
      };

      const animateCarAlongAllRoute = async () => {
        const chunks = smoothRoute.length;
        for (let i = 0; i < chunks - 1; i++) {
          await animateRouteChunk(i);
        }
        setTimeout(async () => {
          await animateWayBack();
          runButton.disabled = false;
          audioTrack.pause();
          audioTrack.currentTime = 0;
        }, 10000);
      };

      function getRoute() {
        const url =
          "https://api.mapbox.com/directions/v5/mapbox/driving/" +
          origin[0] +
          "," +
          origin[1] +
          ";" +
          destination[0] +
          "," +
          destination[1] +
          "?steps=true&geometries=geojson&access_token=" +
          mapboxgl.accessToken;

        fetch(url)
          .then(res => res.json())
          .then(res => {
            const data = res.routes[0];
            route = data.geometry.coordinates;
            console.log(route);
            smoothRoute = [route[0]];
            for (let i = 0; i < route.length; i++) {
              if (i === route.length - 3) {
                console.log(i);
                smoothRoute.push(route[i + 1]);
                smoothRoute.push(route[i + 2]);
                break;
              } else {
                const firstAngle = turf.bearing(
                  turf.point(route[i]),
                  turf.point(route[i + 1])
                );
                const secondAngle = turf.bearing(
                  turf.point(route[i + 1]),
                  turf.point(route[i + 2])
                );

                const delta = ((secondAngle - firstAngle + 540) % 360) - 180;

                if (delta > -10 && delta < 10) {
                  smoothRoute.push(route[i + 2]);
                  i = i + 1;
                } else {
                  smoothRoute.push(route[i + 1]);
                }
              }
            }
            const geojson = {
              type: "Feature",
              properties: {},
              geometry: {
                type: "LineString",
                coordinates: route
              }
            };
            marker = new mapboxgl.Marker(carImage)
              .setLngLat(route[0])
              .addTo(map);
            // if the route already exists on the map, reset it using setData
            if (map.getSource("route")) {
              map.getSource("route").setData(geojson);
            } else {
              // otherwise, make a new request
              map.addLayer({
                id: "route",
                type: "line",
                source: {
                  type: "geojson",
                  data: geojson
                },
                layout: {
                  "line-join": "round",
                  "line-cap": "round"
                },
                paint: {
                  "line-color": "blue",
                  "line-width": 5,
                  "line-opacity": 0.5
                }
              });
            }
            runButton.disabled = false;
          });
      }

      map.on("load", function() {
        getRoute();
        map.addLayer({
          id: "origin",
          type: "circle",
          source: {
            type: "geojson",
            data: {
              type: "FeatureCollection",
              features: [
                {
                  type: "Feature",
                  properties: {},
                  geometry: {
                    type: "Point",
                    coordinates: origin
                  }
                }
              ]
            }
          },
          paint: {
            "circle-radius": 10,
            "circle-color": "#3887be"
          }
        });

        map.addLayer({
          id: "destination",
          type: "circle",
          source: {
            type: "geojson",
            data: {
              type: "FeatureCollection",
              features: [
                {
                  type: "Feature",
                  properties: {},
                  geometry: {
                    type: "Point",
                    coordinates: destination
                  }
                }
              ]
            }
          },
          paint: {
            "circle-radius": 10,
            "circle-color": "#3887be"
          }
        });

        runButton.addEventListener("click", () => {
          // Set the coordinates of the original point back to origin
          marker.setLngLat(origin);

          // play audio
          audioTrack.play();
          runButton.disabled = true;

          animateCarAlongAllRoute();
        });
      });
    </script>
  </body>
</html>
