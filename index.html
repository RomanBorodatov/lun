<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lun NY Truck</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v1.6.1/mapbox-gl.js"></script>
    <script
      src="https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v2.0.0/turf.min.js"
      charset="utf-8"
    ></script>
    <link
      href="https://api.tiles.mapbox.com/mapbox-gl-js/v1.6.1/mapbox-gl.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        height: 100vh;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      #carImage {
        width: 50px;
      }

      #rocketImage {
        width: 50px;
      }

      #giftImage {
        width: 50px;
      }

      .controls-container {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        align-items: center;
      }

      #run-button {
        height: 50px;
        width: 100px;
        background-color: #ff9800;
        border: none;
        border-radius: 25px;
        margin-left: 15px;

        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <img src="./car2.svg" alt="car" id="carImage" />
    <img src="./rocket.svg" alt="rocket" id="rocketImage" />
    <img src="./gift.svg" alt="gift" id="giftImage" />
    <div class="controls-container">
      <audio controls loop src="./music2.mp3" id="audio">
        Your browser does not support the
        <code>audio</code> element.
      </audio>
      <button disabled id="run-button">Run Animation</button>
    </div>
    <script>
      mapboxgl.accessToken =
        "pk.eyJ1Ijoicm9tYW5ib3JvZGF0b3YiLCJhIjoiY2sxa2w3N3Y1MDdvZjNibzNveXFidWpuaSJ9.h9858JVC3HbU02hxED68eg";
      const map = new mapboxgl.Map({
        container: "map",
        style: "mapbox://styles/mapbox/navigation-guidance-night-v4",
        center: [30.472878, 50.384119],
        zoom: 14
      });

      map.dragRotate.disable();
      map.touchZoomRotate.disableRotation();

      const origin = [30.4711555, 50.386974];
      const destination = [30.480598, 50.37886];
      const carImage = document.getElementById("carImage");
      const rocketImage = document.getElementById("rocketImage");
      const giftImage = document.getElementById("giftImage");
      let marker;
      let giftMarker;
      let route;
      let smoothRoute;
      let routeInChunks;
      const runButton = document.getElementById("run-button");
      const audioTrack = document.getElementById("audio");

      const animateRouteChunk = chunk => {
        return new Promise(resolve => {
          let routeChunk = chunk;
          const distance = turf.lineDistance(
            routeChunk.features[0],
            "kilometers"
          );

          const duration = Math.round((distance * 1000) / 0.0139 / 10);

          const currentMarkerAngle = marker.getRotation();
          const currentMarkerPosition = marker.getLngLat();

          const ease = ({ distance, durationMs, onStep }) => {
            const raf =
              window.requestAnimationFrame ||
              (func => window.setTimeout(func, 16));

            const stepCount = durationMs / 16 > 120 ? durationMs / 16 : 120;
            const valueIncrement = distance / stepCount;
            const sinValueIncrement = Math.PI / stepCount;

            let currentValue = 0;
            let currentSinValue = 0;

            const step = () => {
              currentSinValue += sinValueIncrement;
              currentValue +=
                valueIncrement * Math.sin(currentSinValue) ** 2 * 2;

              if (currentSinValue < Math.PI) {
                onStep(currentValue);
                raf(step);
              } else {
                resolve();
              }
            };

            raf(step);
          };

          let initialyRotated = 0;

          const targetAngle = turf.bearing(
            turf.point([currentMarkerPosition.lng, currentMarkerPosition.lat]),
            turf.point(routeChunk.features[0].geometry.coordinates[1])
          );

          const currentAngle = marker.getRotation();

          const delta = ((targetAngle - currentAngle + 540) % 360) - 180;

          const moveMarker = distance => {
            const oldPosition = marker.getLngLat();
            const newPosition = turf.along(
              routeChunk.features[0],
              distance,
              "kilometers"
            ).geometry.coordinates;

            const angleToRotate = turf.bearing(
              turf.point([oldPosition.lng, oldPosition.lat]),
              turf.point(newPosition)
            );

            marker.setLngLat(newPosition);

            if (initialyRotated <= 20) {
              marker.setRotation(currentAngle + delta * 0.05 * initialyRotated);
              initialyRotated += 1;
            } else {
              marker.setRotation(angleToRotate);
            }
          };

          ease({
            distance: distance,
            durationMs: duration,
            onStep: moveMarker
          });
        });
      };

      const animateWayBack = () => {
        return new Promise(resolve => {
          giftMarker = new mapboxgl.Marker(giftImage)
            .setLngLat(destination)
            .addTo(map);
          const roadBack = {
            type: "FeatureCollection",
            features: [
              {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: [destination, origin]
                }
              }
            ]
          };

          const savedPosition = marker.getLngLat();

          const from = turf.point(destination);
          const to = turf.point(origin);

          const distance = turf.lineDistance(
            roadBack.features[0],
            "kilometers"
          );

          const steps = 250;

          const arc = [];

          for (let i = 0; i < distance; i += distance / steps) {
            const segment = turf.along(roadBack.features[0], i, "kilometers");
            arc.push(segment.geometry.coordinates);
          }

          roadBack.features[0].geometry.coordinates = arc;

          let counter = 0;

          animate = () => {
            const currentMarkerPosition = marker.getLngLat();

            if (roadBack.features[0].geometry.coordinates[counter]) {
              const targetAngle = turf.bearing(
                turf.point([
                  currentMarkerPosition.lng,
                  currentMarkerPosition.lat
                ]),
                turf.point(roadBack.features[0].geometry.coordinates[counter])
              );
              marker.setLngLat(
                roadBack.features[0].geometry.coordinates[counter]
              );
              marker.setRotation(targetAngle);
            }

            if (counter < steps) {
              requestAnimationFrame(animate);
            } else {
              resolve();
            }

            counter = counter + 1;
          };
          animate();
        });
      };

      const transformCar = () => {
        return new Promise(resolve => {
          const animate = ({ draw, duration }) => {
            let start = performance.now();

            requestAnimationFrame(function animate(time) {
              let timeFraction = (time - start) / duration;
              if (timeFraction > 1) timeFraction = 1;
              if (timeFraction < 0) timeFraction = 0;

              draw(timeFraction);

              if (timeFraction < 1) {
                requestAnimationFrame(animate);
              }
            });
          };
          const duration = 5000;
          const rounds = 25;
          let transformed = false;
          let currentRotation = marker.getRotation();
          const targetRotation = turf.bearing(
            turf.point(destination),
            turf.point(origin)
          );
          const rotationStep =
            ((currentRotation - targetRotation - 360 * rounds) / duration) * 16;
          const rotate = progress => {
            currentRotation = currentRotation + rotationStep;
            marker.setRotation(currentRotation);
            if (progress > 0.5 && !transformed) {
              marker.remove();
              marker = new mapboxgl.Marker(rocketImage)
                .setLngLat(destination)
                .setRotation(currentRotation)
                .addTo(map);
              transformed = true;
            }

            if (progress >= 1) {
              resolve();
            }
          };

          animate({ draw: rotate, duration: duration });
        });
      };

      const animateCarAlongAllRoute = async () => {
        const length = routeInChunks.length;
        for (let i = 0; i < length; i++) {
          await animateRouteChunk(routeInChunks[i]);
        }
        await transformCar();
        await animateWayBack();
        marker.remove();
        marker = new mapboxgl.Marker(carImage).setLngLat(origin).addTo(map);
        giftMarker.remove();
        runButton.disabled = false;
        alert("Merry Xmas & Happy New Year");
      };

      const generateChunk = coordinates => {
        return {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: coordinates
              }
            }
          ]
        };
      };

      const breakRouteInChunksWithAngle = route => {
        const chunks = [];

        for (let i = 0; i < route.length; i++) {
          const chunkCoords = [route[i]];
          if (i === route.length - 2) {
            chunkCoords.push(route[route.length - 1]);
            chunks.push(generateChunk(chunkCoords));
            break;
          }
          for (let n = i; n < route.length - 2; n++) {
            const firstAngle = turf.bearing(
              turf.point(route[n]),
              turf.point(route[n + 1])
            );
            const secondAngle = turf.bearing(
              turf.point(route[n + 1]),
              turf.point(route[n + 2])
            );

            const delta = ((secondAngle - firstAngle + 540) % 360) - 180;

            if (delta > -25 && delta < 25) {
              chunkCoords.push(route[n + 1]);
            } else {
              chunkCoords.push(route[n + 1]);
              i = n;
              break;
            }
          }
          chunks.push(generateChunk(chunkCoords));
        }
        return chunks;
      };

      const getRoute = () => {
        const url =
          "https://api.mapbox.com/directions/v5/mapbox/driving/" +
          origin[0] +
          "," +
          origin[1] +
          ";" +
          destination[0] +
          "," +
          destination[1] +
          "?steps=true&geometries=geojson&access_token=" +
          mapboxgl.accessToken;

        fetch(url)
          .then(res => res.json())
          .then(res => {
            const data = res.routes[0];
            route = data.geometry.coordinates;
            smoothRoute = [route[0]];
            routeInChunks = breakRouteInChunksWithAngle(route);
            const geojson = {
              type: "Feature",
              properties: {},
              geometry: {
                type: "LineString",
                coordinates: route
              }
            };
            marker = new mapboxgl.Marker(carImage)
              .setLngLat(route[0])
              .addTo(map);
            // if the route already exists on the map, reset it using setData
            if (map.getSource("route")) {
              map.getSource("route").setData(geojson);
            } else {
              // otherwise, make a new request
              map.addLayer({
                id: "route",
                type: "line",
                source: {
                  type: "geojson",
                  data: geojson
                },
                layout: {
                  "line-join": "round",
                  "line-cap": "round"
                },
                paint: {
                  "line-color": "blue",
                  "line-width": 5,
                  "line-opacity": 0.5
                }
              });
            }
            runButton.disabled = false;
          });
      };

      map.on("load", () => {
        getRoute();
        map.addLayer({
          id: "origin",
          type: "circle",
          source: {
            type: "geojson",
            data: {
              type: "FeatureCollection",
              features: [
                {
                  type: "Feature",
                  properties: {},
                  geometry: {
                    type: "Point",
                    coordinates: origin
                  }
                }
              ]
            }
          },
          paint: {
            "circle-radius": 10,
            "circle-color": "#3887be"
          }
        });

        map.addLayer({
          id: "destination",
          type: "circle",
          source: {
            type: "geojson",
            data: {
              type: "FeatureCollection",
              features: [
                {
                  type: "Feature",
                  properties: {},
                  geometry: {
                    type: "Point",
                    coordinates: destination
                  }
                }
              ]
            }
          },
          paint: {
            "circle-radius": 10,
            "circle-color": "#3887be"
          }
        });

        runButton.addEventListener("click", () => {
          marker.setLngLat(origin);
          audioTrack.play();
          runButton.disabled = true;

          animateCarAlongAllRoute();
        });
      });
    </script>
  </body>
</html>
